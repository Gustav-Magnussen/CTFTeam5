## 4001 - Connection Established

> Make a connection to the machine at the correct port and find the flag in flag.txt 


In order to establish a connection to the machine and the correct port, we use NetCat to connect to the port. This is done by using the command `nc`, followed by the target ip and the port to be used.

To be able to confirm that the port has been scanned and that the target machine has been accessed, we use the command `whoami` to be able to see who we are and which privileges can be used. Then `ls` is used to list the available files, including `flag.txt`.

![oppgave1-lab4](https://user-images.githubusercontent.com/46780028/160909838-0c82df23-ca60-4cc9-8aec-ce8d6945b3a7.PNG)

Finally, "cat" is used on `flag.txt` file to open it, thereby revealing the flag.

>**Flag`IKT449{eaarlyyy_m000rr0r0rning}`**


## 4002 - secret
> I forgot the password to my backdoor running at port 4002, can you find it for me?

Trying to execute the attached binary provides the greater than symbol, `>`. This seems to ask for user input and upon entering something the binary responds with `no`. 

![image](https://user-images.githubusercontent.com/59768512/161137298-4634d986-ba55-4802-a910-759d42c359c5.png)

Most likely when prompted to enter something a correct string or password has to be entered. Using the strings command in Linux on the binary reveals any strings within the file. One specific string stands out; `s00p3r_secret_k3ys`. This might be the needed password.

![image](https://user-images.githubusercontent.com/59768512/161137203-af194da4-97c0-48c8-b381-caa9350325b0.png)

Using this password as the user input gives a shell on the machine.

![image](https://user-images.githubusercontent.com/59768512/161138275-cdade4b8-e50c-4331-ad1e-cec6f10e044f.png)

Doing this on the attached port provides a shell on the machine and looking in the current directory shows a `flag.txt` file that contains the flag.

![image](https://user-images.githubusercontent.com/59768512/161138897-826fd8a9-b430-427e-bca5-a9636aef8f3a.png)

>**Flag:`IKT449{nice_l00gin}`**

## 4003 - All Strings Attached

> I forgot the password to my backdoor again.. But I have added some additional obfuscation and false-strings since last time. Could you still help me get in?

This task includes the reversing of a binary file called task3. Running this file displays the greater than symbol, `>`, and seems to ask for user input. Giving user input seems to make the code response with `00ps_d1d_i_m444k33-3rrrr_-it_h4rd_with_ErrR0r-str11nnnzno`. 

![image](https://user-images.githubusercontent.com/59768512/161131323-031f6bca-855f-4ad2-9004-533cee3a3681.png)

This could mean that giving correct user input, or a correct password, would provide another outcome. In order to get an idea of what the this correct input would be the file is opened in IDA Freeware, a tool that is capable of analysing binary files and attempt to recreate what the original C code file looked like before compilation. When the file is opened, psuedocode  can be generated by hitting the `F5` key. This will provide IDA's recreation of how the C code file  originally looked. This psuedocode includes a numbher of strings that is set to a number of different values including parts of what is displayed when providing wrong input. Some of these are strings are used in the password, but as the task mentions, some of these are also false. 

![image](https://user-images.githubusercontent.com/46780028/160911603-3691bb57-8752-4a26-b3cc-273604ea5573.png)

Looking at line 28 the executable seems to provide a shell if the `s` variable is equal to the `s2` variable. Line 25 shows that the `s` variable is what the user enters using `stdin`, this variable is therefore named `input`.  From line 24 the `s2` value seems to be the combined string of variables `v4`, `v8` and `&v8[9]`, given that this is the string needed to pass the boolean expression this is renamed to `password`. In order for this code to make a little more sense the variable `v4` is given the name `first` while the `v8` variable is given the name `second`. In line 23 the value for the `second` varaiable, the value `dr4h_ti-` is reveresed. When reversed the string changes to `-it_h4rd`. When the three selected strings are successfully connected, the the final `password` variable; `00ps_d1d_i_m444k33-3rrrr_-it_h4rd_with_ErrR0r-str11nnnz`.

![image](https://user-images.githubusercontent.com/59768512/161133422-eedc38ea-25e2-4d93-8e9c-1ac4a13cbd31.png)

Using this `password` variable as the input when prompted provides a shell on the target machine. Looking at the files contained in the current directory the `cat` command can be used on the `flag.txt` file to reveal the flag.

![image](https://user-images.githubusercontent.com/46780028/161066318-b988b0fe-1f7d-4618-93fa-ab984b7887ae.png)

>**Flag:`IKT449{siml33_mag1c_w00rd}`**
 

## 4004 - INTelligence
> I have moved from passwords to PINs for my backdoors, is it still secure though?

Running the attached file seems to ask for a PIN code and return `no` if the PIN code is wrong.

![image](https://user-images.githubusercontent.com/59768512/158981968-c814230a-f6c9-4b50-b2a9-14f72a1b6ee6.png)

Opening the file in IDA Freeware and generating pseudocode for the main functions gives a bit of understanding of what happens when running the binary.

![image](https://user-images.githubusercontent.com/59768512/158981863-611d4047-8441-4754-8e95-3e1637705216.png)

The `fgets(s, 30, stdin9;` seems to take the user input and puts it into the variable `s`, while the variable `&v5[13]` seems to be what it is compared to. Renaming the `s` variable to `user-input`  and the `v5` to `password` will help with readability. Looking at lines 16 and 17, the main function calls the library function `strcpy` and adds the integer values to the `password` and `src` variables. At this point in the code, the `password` variable is `123454652311` and the `src` variable is `22`.

![image](https://user-images.githubusercontent.com/59768512/158984054-94d38097-f91a-4ddf-8e00-e37ae5ebd863.png)

Looking at lines 20 and 21 the library function `strcat` gets called and adds the string of the `src` variable to the `password` variable and later the string of the `password` variable as well. This means that the final `&password[13]` variable contains the string `22123454652311` which should be the pin.

![image](https://user-images.githubusercontent.com/59768512/158984306-202f5e3a-22e2-4a8c-be52-188914d4742a.png)

Using this pin confirms this theory and gives shell. 

![image](https://user-images.githubusercontent.com/59768512/161140284-e93681a6-2b31-4d91-865f-6ef0978d959b.png)

Using this pin on the attached port gives a shell on the machine in the directory where the `flag.txt` file is located.

![image](https://user-images.githubusercontent.com/59768512/161140454-0d8cb553-6f7f-4aa2-aaab-27ffdb1f713d.png)

>**Flag:`IKT449{P1N_RIGHT_UP_T1s_c5all}`**

## 4005 - screw it

>*I give up, no more passwords, no more backdoor. This is just a simple app which provides your string in return. Nothing else that is strange right?*

The task grants us with two files: task5 and task5.c. task5 is a compiled C-program that returns the value in which is put in by the user, while task5.c is the non-compiled raw code of the program. Below is the source code with some additional comments to explain how the program functions:

![image](https://user-images.githubusercontent.com/70077872/160817314-686c72c2-6a3c-41f7-ba45-a89ee48c8f61.png)

As seen in the picture above, the program defined a maximum flag size of 64 characters. It also includes a function `sigsegv_handler` that prints the flag file. This is the function we want to invoke to retrieve our flag. Further down, the `main` function reads the flag file, and if the flag file is present, it invokes the `SIGSEGV` which runs the `sigsegv_handler` function.  Lastly, the program defines a buffer size of 128 characters, but the problem is that is also outputs up to 256 characters of data. This flaw contributes to a buffer overflow vulnerability. 

In our case, to invoke the `sigsegv_handler` functions that prints the flag, we have to overflow the input with characters. Since the buffer is 128 characters, and the max size of the flag is 64 characters, we use Python to give us 200 characters to be safe:

![image](https://user-images.githubusercontent.com/70077872/160821819-43981c87-14ef-4384-9cfa-a52477e2346f.png)

Then, after getting our 200 characters, the program is run and the characters are put in. The program then returns our string along with the flag which is read from out-of-bounds memory:

![image](https://user-images.githubusercontent.com/70077872/160821983-f3dcea7d-da8f-4e1e-9774-6c055e4fce5f.png)


>**Flag:`IKT449{B0000000000000000000_big_00000000000000000000F}`**

## PY - 01
 > *This is a bit rotte(n)*

The task provided a code snippet and a text file with the output after running the code with a secret input, which was the flag. To find the flag, it was necessary to analyze the code carefully. 

![image](https://user-images.githubusercontent.com/72946914/161009970-6701dbae-d10b-41cc-9a30-3cd1018fe92b.png)

As we can see from the code snippet, there are two unknown variables: the flag and a secret number. The secret number makes the task more difficult to solve, as it provides a variation that can affect the output completely. 

The text file had the following content: 
```python
0xb4,0xb7,0xc1,0xa2,0xa3,0xa9,0xec,0xe4,0xa3,0xe8,0xd6,0xea,0xdc,0xd7,0xe6,0xad,0xda,0xc8,0xae,0xe9,0xe4,0xdf,0xe4,0xe7,0xe4,0xfe,0xff,0xba,0xf9,0xe7,0x100,0xbb,0xfe,0xf4,0xec,0xf6,0xc2,0xef,0xf5,0xc3,0xf7,0x111
```
We saved the output in a variable with the same name. It was also necessary to have a variable to catch the flag, called `flag`. 

In the provided code snippet, the secret number is added to the flag's characters after turning it into an integer representing the Unicode characters. Then the integer is turned into the corresponding hex decimal value. In every iteration, the secret number is increased by one. To decrypt the output, we wrote a code that did the operations in the opposite order, starting by subtracting the secret number, then followed by the other operations: 

![image](https://user-images.githubusercontent.com/72946914/161015249-33c331e8-f7e8-464b-90b5-a983284a92b8.png)

Having `secret_number = 0`, we concentrated around the first six integers provided by printing `real_int`, since we knew that the flag would start with `IKT449`: 
```python
180
182
191
159
159
164 
```
The decimal value of `I` is 73; thus, subtracting that number from the number we got resulted in 107. Entering 107 as the secret number gave the following output: 

>**Flag:`IKT449{r0tate_m3_L1ke_ceazz4r_w1sh_h3_d1d}`**

## PY - 02
> *One secret might not be enough, but how about two?*

The task describtion provided us with the same material here; a code snippet and a text file with the output. This time, the result was a list consisting of the following integers: 
```python
111,88,37,87,81,90,81,97,81,96,81,90,91,91,81,90,81,102,87,88,34,101,43,38,61,102,37,37,94,87,102,97,102,86,83,102,89,91,100,87,102,34,81,94,88,90,109,38,70,59
```
After reading through the below code snippet, we got an idea of what was happening. First, all the flag's characters are turned into their corresponding Unicode character before the value of `secret_number_1` was added. Then the encrypted list, `enc`, is flipped around before every other element is added to a new list, `cne2`. Then the remaining elements are added to `cne2`, as the list's second half. At last, the numbers are subtracted with `secret_number_2`. 

![image](https://user-images.githubusercontent.com/72946914/161036498-dcd84999-a449-4877-bcd4-4e55bce35e75.png)

This time it is not as simple as flipping the code around, like in the previous task. We are dealing with two unknown numbers and a flag that has been completely turned around and twisted. 

For starters, we defined the two variables `secret_number_1` and `secret_number_2` to equal zero, making it easier to understand which output we are dealing with before adding arbitrary values to the variables. To start where the code snippet left off, we iterated through the output elements and added `secret_number_2`. 

![image](https://user-images.githubusercontent.com/72946914/161040129-c89f599c-347c-43ec-b0ec-7a1ffcf2d023.png)

As `cne2` is divided into two parts, containing the first added and the second added numbers from `cne`, we started by dividing the list into two parts, trying to reconstruct the original list. Then we flipped both of them to get their initial order. 

![image](https://user-images.githubusercontent.com/72946914/161040570-b4c471d6-349c-4175-bfc0-9a25dde042d0.png)

By going through the code with pen and paper, with `IKT449` as the flag (which we knew was the flag's starting character), we understood that the list would be something like this:

```python
first_half = K49
second_half = IT4
```
To zip them together to obtain the right order, we used the Python function called `zip()`, which does exactly that. Then, we went through the values of the zipped list and turned them into characters after subtracting `secret_number_1`. The complete code now looks like this: 

![image](https://user-images.githubusercontent.com/72946914/161042062-905ea0af-4a4c-4578-b798-6601ed78a6d4.png)

Giving us the following result: 

```python
Result:  [(59, 61), (70, 38), (38, 43), (109, 101), (90, 34), (88, 88), (94, 87), (81, 102), (34, 81), (102, 90), (87, 81), (100, 91), (91, 91), (89, 90), (102, 81), (83, 96), (86, 81), (102, 97), (97, 81), (102, 90), (87, 81), (94, 87), (37, 37), (37, 88), (102, 111)]
Flag:  ;=F&&+meZ"XX^WQf"QfZWQd[[[YZfQS`VQfaaQfZWQ^W%%%Xfo
```

Like the previous task, we want the first number in the list `Result` to be 73, which equals the letter `I`. Since 73 - 59 = 14, we knew we had to add 14 to either of the secret numbers. Trying `secret_number_2 = 14` did not change much, but setting `secret_number_1 = -14` (negative 14, since `secret_number_1` is subtracted from the elements in the list, and we want it added), we obtained the flag: 

>**Flag:`IKT449{sh0ffle_t0_the_riiight_and_too_the_le333ft}`**




